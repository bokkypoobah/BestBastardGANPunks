<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />

    <title>BESTBASTARDGANPUNKS</title>

    <link type="text/css" rel="stylesheet" href="css/bootstrap.min.css" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue-icons.min.css"/>

    <!-- Load polyfills to support older browsers -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es2015%2CIntersectionObserver"></script>

    <script src="js/vue.js"></script>
    <script src="js/bootstrap-vue.min.js"></script>
    <script src="js/bootstrap-vue-icons.min.js"></script>
    <script src="js/dexie.js"></script>
    <script src="js/libgif.js"></script>

    <script src="js/ethers-5.2.umd.min.js"></script>
    <!-- <script src="js/apexcharts.js"></script> -->

    <!-- ENS stuff -->
    <script src="js/punycode.js"></script>
    <script src="js/idna-map.js"></script>
    <script src="js/idna-uts46-hx.js"></script>
    <script src="js/js-sha3.js"></script>
    <script src="js/eth-ens-namehash.js"></script>

    <script src="bastardData.min.js"></script>
    <script src="deploymentData.js"></script>

    <link rel="apple-touch-icon" sizes="57x57" href="images/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="images/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="images/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="images/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="images/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="images/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="images/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="images/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="images/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
    <link rel="manifest" href="images/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="images/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">

  </head>
  <body>
    <div id="app">
      <b-container fluid class="m-0 p-2">
        <div>
          <b-navbar variant="light">
            <b-navbar-brand to="./" variant="primary" v-b-popover.hover.bottom="'Best BastardGANPunks'">
              BESTBASTARDGANPUNKS
            </b-navbar-brand>
            <div v-if="getTotalSupply > 100" v-for="item in getSelectedShowcase">
              <b-link @click="displayToken(item)">
                <b-avatar rounded="sm" variant="light" size="3.0rem" :src="data[item].osimage" v-b-popover.hover.bottom="'#' + item" class="ml-2"></b-avatar>
              </b-link>
            </div>
            <b-navbar-nav class="ml-auto">
              <b-button size="sm" variant="outline-primary" class="ml-4" v-b-popover.hover="'CONNECT TO SEE YOUR BASTARDS'" @click="connect();" v-if="!connected">CONNECT MY FUCKING WALLET</b-button>
              <b-button size="sm" variant="outline-primary" class="ml-4" v-b-popover.hover="'DISCONNECT TO SEE BOKKY\'S BASTARDS'" @click="disconnect();" v-if="connected">MY FUCKING WALLET {{ ensOrShortName(account) }}</b-button>
            </b-navbar-nav>
          </b-navbar>
        </div>

        <div>
          <b-card no-body class="mt-1">
            <div>
              <b-modal ref="my-modal" hide-footer @shown="onGIFFrameSelectionModalOpened">
                <template #modal-title>
                  {{ selectedTokenId == null ? null : data[selectedTokenId].name }}
                  <span v-if="selectedItemIsGIF"> - Frame {{ selectedItemFrame == null ? '(loading)' : selectedItemFrame }}</span>
                </template>
                <div class="d-block text-center">
                  <img id="thegif1" :src="selectedTokenId == null ? null : data[selectedTokenId].osimage" :rel:animated_src="selectedTokenId == null ? null : data[selectedTokenId].osimage" width="400" height="400" rel:auto_play="0" rel:rubbable="1" class="pr-3" />
                </div>
                <b-input-group v-if="selectedItemIsGIF">
                  <template #prepend>
                    <b-form-spinbutton wrap @change="setFrame()" v-model.trim="selectedItemFrame" min="0" :max="selectedItemFrames == null ? 0 : (selectedItemFrames - 1)" class="mr-2"></b-form-spinbutton>
                    <b-input-group-text>0</b-input-group-text>
                  </template>
                  <b-form-input @change="setFrame()" v-model.trim="selectedItemFrame" type="range" min="0" :max="selectedItemFrames == null ? 0 : (selectedItemFrames - 1)" class="w-25"></b-form-input>
                  <template #append>
                    <b-input-group-text>{{ selectedItemFrames == null ? 0 : (selectedItemFrames - 1) }}</b-input-group-text>
                  </template>
                </b-input-group>
              </b-modal>
            </div>

            <template>
              <div>
                <b-sidebar right id="sidebar-border" sidebar-class="border-right border-danger">
                  <div v-for="(categoryKey, categoryIndex) in Object.keys(categories).sort()" v-bind:key="categoryIndex">
                    <b-card body-class="p-0" header-class="m-0 p-0 pl-2" footer-class="p-1" class="m-3 p-0">
                      <template #header>
                        <span variant="secondary" class="small truncate">
                          {{ categoryKey }}
                        </span>
                      </template>
                      <font size="-2">
                        <b-table small fixed striped sticky-header="200px" :fields="categoryFields" :items="getSortedValuesForCategory(categoryKey)" head-variant="light">
                          <template #cell(select)="data">
                            <b-form-checkbox @change="filterChange(categoryKey, data.item.categoryOption)"></b-form-checkbox>
                          </template>
                        </b-table>
                      </font>
                    </b-card>
                  </div>
                </b-sidebar>
              </div>
            </template>

            <div v-if="processing == null && searchAccount != null && searchAccount.length > 0 && collatedOwners.length == 0">
              <b-jumbotron header="WEB3 CONNECTION REQUIRED" bg-variant="info" text-variant="white" border-variant="dark" class="m-5 p-5">
                TO RETRIEVE ERC-721 TOKEN OWNERSHIP AND ENS INFOMRATION. YOU CAN CONTINUE USING THIS TOOL WITHOUT A CONNECTION BUT OWNER INFORMATION AND SEARCH WILL NOT WORK. CLICK ON THE BUTTON ON THE TOP RIGHT TO CONNECT. CLEAR THE OWNER SEARCH FIELD TO REMOVE THIS MESSAGE.
              </b-jumbotron>
            </div>

            <div v-if="processing != null">
              <b-jumbotron header="PROCESSING" bg-variant="info" text-variant="white" border-variant="dark" class="m-5 p-5">
                {{ processing }}
              </b-jumbotron>
            </div>

            <b-tabs card v-model="tabIndex" align="right">

              <b-tab title="SEXY BASTARDS">
                <b-card-text>
                  <div class="d-flex m-0 p-0" style="height: 75px;">
                    <div>
                      <b-form-input type="text" size="sm" @change="recalculate('search')" v-model.trim="searchString" debounce="600" placeholder="🔍 TOKENID/LYRICS"></b-form-input>
                    </div>
                    <div class="pl-2">
                      <b-form-input type="text" size="sm" @change="recalculate('searchAccount')" v-model.trim="searchAccount" debounce="600" placeholder="🔍 OWNER ENS/ADDY"></b-form-input>
                    </div>
                    <!--
                    <div class="pl-2">
                      <b-button v-b-toggle.collapse-search size="sm" variant="none"><b-button size="sm" variant="link" class="m-0 p-0" v-b-popover.hover="'ADVANCED SERACH'" ><b-icon-filter shift-v="+1" font-scale="1.7"></b-icon-filter></b-button></b-button>
                    </div>
                    -->
                    <div class="pl-2">
                      <b-button size="sm" @click="searchAccount = account; recalculate('mytokens')" variant="outline-primary"><< MY SEXY BASTARDS</b-button>
                    </div>
                    <div class="pl-2">
                      <b-form-select size="sm" @change="recalculate('selectedTags')" v-model="selectedTags" :options="getTags" multiple :select-size="3" variant="outline-primary"></b-form-select>
                    </div>
                    <div class="pr-1 flex-grow-1">
                    </div>
                    <div class="pl-2">
                      <font size="-2">{{ tokensSearchResults.length }}/{{ getTotalSupply }}</font>
                    </div>
                    <div class="pl-2">
                      <b-pagination size="sm" v-model="tokensCurrentPage" :total-rows="tokensSearchResults.length" :per-page="tokensPageSize"></b-pagination>
                    </div>
                    <div class="pl-2">
                      <b-form-select size="sm" v-model="tokensPageSize" :options="pageSizes"></b-form-select>
                    </div>
                    <div class="pl-2">
                      <b-form-select size="sm" v-model="view" :options="viewOptions"></b-form-select>
                    </div>
                    <div class="pl-2">
                      <b-button v-b-toggle.sidebar-border size="sm" variant="none"><b-button size="sm" variant="link" class="m-0 p-0" v-b-popover.hover="'ADVANCED SERACH'" ><b-icon-search shift-v="+1" font-scale="1.3"></b-icon-search></b-button></b-button>
                    </div>
                  </div>

                  <div>
                    <!-- visible -->
                    <b-collapse id="collapse-search" class="m-2">
                      <b-card>
                        <b-row v-for="(categoryKey, categoryIndex) in Object.keys(categories).sort()" v-bind:key="categoryIndex">
                          <b-col cols="2" class="text-right"> {{ categoryKey }}</b-col>
                          <b-col cols="6">
                            <font size="-2">
                              <b-table small fixed striped sticky-header="200px" :fields="categoryFields" :items="getSortedValuesForCategory(categoryKey)" head-variant="light">
                                <template #cell(select)="data">
                                  <b-form-checkbox @change="filterChange(categoryKey, data.item.categoryOption)"></b-form-checkbox>
                                </template>
                              </b-table>
                            </font>
                          </b-col>
                        </b-row>
                      </b-card>
                    </b-collapse>
                  </div>

                  <div v-if="view == 'cards'">
                    <b-card-group deck>
                      <div v-for="record in pagedTokensResults">
                        <b-card body-class="p-1" header-class="p-1" footer-class="p-1" img-top class="m-1 p-0">
                          <template #header>
                            <span variant="secondary" class="small truncate">
                              {{ '#' + record.tokenId }}
                            </span>
                          </template>
                          <!--
                          <b-link :href="record.permalink + '?ref=0x000001f568875F378Bf6d170B790967FE429C81A'" v-b-popover.hover="'View on OpenSea.io'" target="_blank">
                            <b-img-lazy width="220%" :src="record.osimage" />
                            -->
                            <!-- <b-avatar rounded="sm" variant="light" size="15.0rem" :src="record.osimage"></b-avatar> -->
                          <!-- </b-link> -->
                          <b-link @click="displayToken(record.tokenId)" v-b-popover.hover="'CLICK FOR DETAILS'">
                            <b-img-lazy width="150%" :src="record.osimage" />
                          </b-link>
                        </b-card>
                      </div>
                    </b-card-group>
                  </div>
                  <div v-if="view == 'list'">
                    <b-table small :fields="fields" :items="pagedTokensResults" responsive="sm">
                      <template #cell(image)="data">
                        <b-link @click="displayToken(data.item.tokenId)" v-b-popover.hover="'Click for details'">
                          <b-img-lazy width="300%" :src="data.item.osimage" />
                          <!-- <b-avatar rounded="sm" variant="light" size="10.0rem" :src="data.item.osimage"></b-avatar> -->
                        </b-link>
                        <!--
                        <b-link :href="data.item.permalink + '?ref=0x000001f568875F378Bf6d170B790967FE429C81A'" v-b-popover.hover="'View on OpenSea.io'" target="_blank">
                        </b-link>
                        -->
                      </template>

                      <template #cell(tokenId)="data">
                        <b-link :href="data.item.permalink + '?ref=0x000001f568875F378Bf6d170B790967FE429C81A'" v-b-popover.hover="'VIEW NFT IN OPENSEA'" target="_blank">
                          {{ data.item.tokenId }}
                        </b-link>
                        <br />
                        <span v-if="owners.length > 0">
                          <b-link :href="'https://opensea.io/accounts/' + owners[data.item.tokenId]" v-b-popover.hover="'VIEW OWNER ACCOUNT IN OPENSEA'" target="_blank">
                            <font size="-2">{{ ensOrShortName(owners[data.item.tokenId]) }}</font>
                          </b-link>
                          <!--
                          <b-link :href="'https://opensea.io/accounts/' + owners[data.item.tokenId]" v-b-popover.hover="'View in OpenSea'" target="_blank">
                            <b-icon-link shift-v="+1" font-scale="1.0"></b-icon-link>
                          </b-link>
                          -->
                        </span>
                        <b-link size="sm" @click="searchAccount = owners[data.item.tokenId]; tabIndex = 0; recalculate('tokenSearch'); " v-b-popover.hover="'FILTER BY OWNER ACCOUNT'" variant="link">
                          <b-icon-search shift-v="+1" font-scale="1.0"></b-icon-search>
                        </b-link>
                        <span v-if="data.item.mosaicurl != null">
                          <b-link :href="data.item.mosaicurl" v-b-popover.hover="'VIEW HYPED AF (ANIMATED) MOSAIC'" target="_blank">
                            <b-icon-grid3x3-gap shift-v="+1" font-scale="1.0"></b-icon-grid3x3-gap>
                          </b-link>
                        </span>

                        <b-form-tags @input="saveTags" v-model="tags[data.item.tokenId]" tag-variant="primary" tag-pills size="sm" separator=" " placeholder="ENTER NEW TAGS" class="ml-0 mt-1"></b-form-tags>

                      </template>
                      <template #cell(description)="data">
                        <span v-for="line in data.item.description.split('\n')">
                          <b>{{ line }}</b><br />
                        </span>
                      </template>
                      <template #cell(attributes)="data">
                        <b-row v-for="attribute in data.item.attributes"  v-bind:key="attribute.trait_type" class="m-0 p-0">
                          <b-col class="m-0 p-0"><font size="-3">{{ attribute.trait_type }}</font></b-col><b-col class="m-0 p-0"><b><font size="-2">{{ attribute.value }}</font></b></font></b-col>
                        </b-row>
                      </template>
                    </b-table>
                  </div>
                </b-card-text>
              </b-tab>

              <!--
              <b-tab title="MY FUCKING WALLET">
                <b-card-text>
                  SELECT <em>MY SEXY BASTARDS</em> IN THE PREVIOUS TAB TO VIEW YOUR BASTARDS.<br />
                  <b-table small :fields="ownedTokenFields" :items="getOwnedTokenIdData" responsive="sm">
                  </b-table>
                </b-card-text>
              </b-tab>
              -->

              <b-tab active title="DATA">
                <b-card-text>
                  <b-link @click="loadOSData()">
                    LOAD DATA
                  </b-link>
                </b-card-text>
              </b-tab>

              <b-tab lazy title="OWNERS">
                <b-card-text>
                  <div class="d-flex m-0 p-0" style="height: 37px;">
                    <!--
                    <div>
                      <b-form-input type="text" size="sm" @change="recalculate('search')" v-model.trim="searchString" debounce="600" placeholder="SEARCH..." v-b-popover.hover="'SEARCH BY TOKENID, WORD IN LYRICS OR OWNER ADDRESS'"></b-form-input>
                    </div>
                    -->
                    <div class="pr-1 flex-grow-1">
                    </div>
                    <div class="pl-2">
                      <font size="-2">Unique Owners: {{ collatedOwners.length }} ({{ ((collatedOwners.length*100)/getTotalSupply).toFixed(2) + '%' }}); Total Supply: {{ getTotalSupply }}. Connect your wallet to retrieve up-to-date owner data</font>
                    </div>
                    <div class="pl-2">
                      <b-pagination size="sm" v-model="ownersCurrentPage" :total-rows="collatedOwners.length" :per-page="tokensPageSize"></b-pagination>
                    </div>
                    <div class="pl-2">
                      <b-form-select size="sm" v-model="ownersPageSize" :options="pageSizes"></b-form-select>
                    </div>
                    <!--
                    <div class="pl-2">
                      <b-form-select size="sm" v-model="view" :options="viewOptions"></b-form-select>
                    </div>
                    <div class="pl-2">
                      <b-button v-b-toggle.sidebar-border size="sm" variant="none"><b-button size="sm" variant="link" class="m-0 p-0" v-b-popover.hover="'ADVANCED SERACH'" ><b-icon-search shift-v="+1" font-scale="1.3"></b-icon-search></b-button></b-button>
                    </div>
                    -->
                  </div>

                  <b-table small :fields="ownersFields" :items="pagedCollatedOwnersResults" responsive="sm">
                    <template #cell(index)="data">
                      {{ data.item.index }}
                    </template>
                    <template #cell(owner)="data">
                      {{ ensOrShortName(data.item.owner) }}<br />
                      {{ data.item.tokens.length + ' (' + (data.item.tokens.length*100/getTotalSupply).toFixed(2) + '%)'}}<br />
                      <b-link :href="'https://opensea.io/accounts/' + data.item.owner + '?search[sortAscending]=false&search[sortBy]=LAST_TRANSFER_DATE'" v-b-popover.hover="'VIEW OWNER ACCOUNT IN OPENSEA'" target="_blank">
                         <b-icon-link shift-v="+1" font-scale="1.0"></b-icon-link>
                      </b-link>
                      <b-link size="sm" @click="searchAccount = data.item.owner; tabIndex = 0; recalculate('ownerSearch'); " variant="outline-primary" v-b-popover.hover="'FILTER BY OWNER ACCOUNT'" >
                        <b-icon-search shift-v="+1" font-scale="1.0"></b-icon-search>
                      </b-link>
                    </template>
                    <template #cell(tokens)="data">
                      <span v-for="token in data.item.tokens">
                        <b-link :href="'https://opensea.io/assets/0x31385d3520bced94f77aae104b406994d8f2168c/' + token" v-b-popover.hover="'VIEW IN OPENSEA'" target="_blank">
                          {{ token }}
                        </b-link>
                      </span>
                    </template>
                  </b-table>
                </b-card-text>
              </b-tab>

              <b-tab title="INFO">
                <h6 class="mb-1">WHAT IS THIS WEBSHITE ABOUT?</h6>
                <b-card-text>
                  A SMOL WEB3 APP TO VIEW YOUR BASTARD GAN PUNKS FROM <a href="https://www.bastardganpunks.club/" target="_blank">https://www.bastardganpunks.club/</a>. OPEN SAUCED CODE IS AVAILBLE FOR YOUR TO IMPROVE ON - SEE BELOW.

                  THIS SITE CURRENTLY LISTS BGANPUNKV2 (VERSION 2) NFTS, NOT BGANPUNKV1 (VERSION 1) <a href="https://bganpunks.eth.link/" target="_blank">https://bganpunks.eth.link/</a>.

                  READ MORE ABOUT BGANPUNKS AT <a href="https://mooncat888.medium.com/introduction-to-bastard-gan-punk-v2-nft-art-collection-c5bb0750432c" target="_blank">Introduction to Bastard Gan Punk V2 NFT art collection</a>.
                </b-card-text>

                <b-card-text>
                  WER ARE NOT AFFILIATED WITH <a href="https://twitter.com/bganpunks" target="_blank">THESE BASTARDS</a> WITH A SANDWICH LOGO. IF YOU HAVE QUESTIONS, HEAD OVER TO THEIR DISCORD, LINEKD FROM THE URLS ABOVE.
                  <b-card no-body img-src="images/Twitter_bganpunks.png" style="max-width: 20rem;" class="mt-1 ml-5"></b-card>
                </b-card-text>

                <b-card-text>
                  NFT AND IMAGE COPYRIGHT INFO SEE <a href="https://www.bastardganpunks.club/#nftownership" target="_blank">https://www.bastardganpunks.club/#nftownership</a>.

                  A COPY OF THE <a href="https://drive.google.com/drive/folders/1dLnTSUhDlgfdUlzwm1pamiAWUyGVOGj-" target="_blank">HYPED AF MOSAICS</a> HAS BEEN INCLUDED WITH THIS WEBSHITE TO ORGANISE FOR EASIER ACCESS. ONLY THE HYPED AF (ANIMATED) MOSAICS IN THE FIRST 9,000 (#0 to #8,999) TOKENS HAVE BEEN ORGANISED AND THIS REPOSITORY WILL HAVE TO BE UPDATED WHEN THE ORGANISED MOSAICS ARE FINALLY PUBLISHED.
                </b-card-text>

                <h6 class="mt-4 mb-1">HOW DO I ADOPT SOME BASTARDS?</h6>
                <b-card-text>
                  THE LAST BASTARD WAS MINTED (SEE BELOW) AT <a href="https://etherscan.io/tx/0x8540f856b6db0eab792fda749730865a10178260da06541c84cf585d8dc60592" target="_blank">Jun-25-2021 04:53:13 PM +UTC</a> THROUGH A PROXY CONTRACT AND THERE ARE NO MORE BASTARDS TO ADOPT.

                  BGANPUNKV2 NFTS CAN BE PURCHASED FROM SECONDARY ERC-721 MARKETS SUCH AS <a href="https://opensea.io/collection/bastard-gan-punks-v2" target="_blank">https://opensea.io/collection/bastard-gan-punks-v2</a>.

                  SEE ALSO <a href="https://allbastards.com/" target="_blank">https://allbastards.com/</a> and <a href="https://nftexp.io/explore/bastard-gan-punks-v2" target="_blank">https://nftexp.io/explore/bastard-gan-punks-v2</a> FOR MORE INFROMATION.

                  THIS IS NOT FINANCIAL ADVICE. DO YOUR OWN FUCKING RESEARCH.
                </b-card-text>

                <h6 class="mt-4 mb-1">CONTRACT DETAILS</h6>
                <b-card-text>
                  THE BGANPUNV2 NFT SMART CONTRACT AT <a href="https://etherscan.io/address/0x31385d3520bCED94f77AaE104b406994D8F2168C#code" target="_blank">0x31385d3520bCED94f77AaE104b406994D8F2168C</a>:
                  <ul>
                    <li>WAS DEPLOYED AT <a href="https://etherscan.io/tx/0xd875fb294bf841eaf7bffae94bd5488d78f227e9b4a3017105bae31b296419ce" target="_blank">Mar-07-2021 12:03:56 PM +UTC</a> WHERE TOKENS #0 TO 33 WERE MINTED</li>
                    <li>MINTED THE FINAL TOKEN #11,304 AT <a href="https://etherscan.io/tx/0x8540f856b6db0eab792fda749730865a10178260da06541c84cf585d8dc60592" target="_blank">Jun-25-2021 04:53:13 PM +UTC</a> THROUGH A PROXY CONTRACT WITH A DECLINING PRICE</li>
                  </ul>
                  <b-card img-src="images/EtherScan_BGANPUNKSV2_20210703_2211.png" style="max-width: 40rem;" class="ml-5">
                    <b-card-text>
                      ETHERSCAN'S <a href="https://etherscan.io/token/tokenholderchart/0x31385d3520bced94f77aae104b406994d8f2168c" target="_blank">BASTARD GAN PUNKS V2 TOKEN HOLDERS @ Jul 3 2021</a>
                    </b-card-text>
                  </b-card>
                </b-card-text>

                <h6 class="mt-4 mb-1">ABOUT THIS APP</h6>
                <b-card-text>
                  <ul>
                    <li>SOURCE CODE AVAILABLE AT <a href="https://github.com/bokkypoobah/BestBastardGANPunks" target="_blank">https://github.com/bokkypoobah/BestBastardGANPunks</a>. CLONE IT, FORK IT. CONTRIBUTE ANY USEFUL CHANGES BACK TO THIS MAIN REPOSITORY.</li>
                    <li>THE MAIN BIT OF CODE IS IN <a href="https://github.com/bokkypoobah/BestBastardGANPunks/blob/main/docs/index.html#L416" target="_blank">https://github.com/bokkypoobah/BestBastardGANPunks/blob/main/docs/index.html</a>.</li>
                    <li>TO SEE HOW IT WORKS, SWITCH TO YOUR WEB BEOWSER DEVELOPER CONSOLE AND TRY STRPPING THROUGH THE SOURCE CODE.</li>
                    <li>WRITTEN USING THE <a href="https://bootstrap-vue.org/" target="_blank">https://bootstrap-vue.org/</a> FRAMEWWORK</li>
                    <li>GENERATES "STATIC" DATA BY COLLATING INFOTMSTION FROM THE TOKEN CONTACT'S <em>tokenURI(...)</em> INFORMATION WITH THE INFOTRMATION FROM OPENSEA.IO.</li>
                    <li>USES <a href="https://github.com/ethers-io/ethers.js/" target="_blank">ETHERS.JS</a> TO CONNECT TO ETHERUEM VIA WEB3 TO RETRIEVE NFT TOKENS OWNED</li>
                    <li>HAS NO TRACKIING TECHNOLOGY. HOWEVER CONNECTIONS FROM THIS APP TO OPENSEA AND YOUR WEB3 PROVIDER WILL LEAK SOME INFORMATION.</li>
                    <li>CAN BE RUN ON YOUR OWN COMPUTER BY CLONING THE GITHUB REPOSITORY AND SERVING THE PAGES USING A WEBSERVER, OR THE "ANYWHERE" SERVER.</li>
                    <li>CAN BE RUN FROM GITHUB PAGES, SO YOU CAN EASILY CLONE, CUSTOMISE AND SERVE YOUR OWN VERSION</li>
                    <li>THIS APP DOES ADD A REF LINK TO MY ACCOUNT TO OPENSEA URLS</li>
                  </ul>
                </b-card-text>

                <h6 class="mt-4 mb-1">SUPPORT A POOR DEVLOPER BASTARD</h6>
                <b-card-text>
                  <ul>
                    <li>SEND YOUR FUCKING DONATIONS TO BokkyPooBah.eth. FLOOR BGANPUNKV2S, NFTS, ETH AND ERC20S ALL APPRECIATED. DON'T BE A FUCKING STINGY BASTARD!!!</li>
                  </ul>
                </b-card-text>

                <b-card-text class="ml-5 mt-5">
                  ENJOY!
                  <b-card no-body img-src="images/DoomedDegen.png" style="max-width: 20rem;" class="mt-1 ml-2"></b-card>
                  (C) BOKKYPOOBAH / BOK CONSULTING PTY LTD 2021. THE MIT LICENCE.
                </b-card-text>
              </b-tab>
            </b-tabs>
          </b-card>
        </div>
      </b-container>
    </div>

    <script>
      window.app = new Vue({
        el: '#app',
        data: {
          processing: null,
          connected: false,
          account: null,
          tokensOwned: [],
          owners: [],
          ensMap: {},
          osAssets: {},
          tags: {},
          selectedTags: [],
          collatedOwners: [],
          tabIndex: 0,
          searchString: '',
          searchAccount: '',

          data: [],
          categories: {},

          tokensSearchResults: [],

          tokensCurrentPage: 1,
          tokensPageSize: 100,
          ownersCurrentPage: 1,
          ownersPageSize: 10,

          pageSizes: [
            { value: 10, text: '10/P' },
            { value: 100, text: '100/P' },
            { value: 666, text: '666/P' },
            { value: 2145, text: '2,145/P' },
            { value: 66666, text: 'ALL' },
          ],

          selectedTokenId: null,
          selectedItemFrame: 0,
          selectedItemFrames: null,
          selectedItemIsGIF: false,
          selectedItemGIF: null,

          view: 'list',
          viewOptions: [
            { value: 'cards', text: 'CARDS' },
            { value: 'list', text: 'LIST' },
          ],
          categoryFields: [
            { key: 'select', label: '', thStyle: 'width: 10%;' },
            { key: 'categoryOption', label: 'TYPE', sortable: true },
            { key: 'categoryTotal', label: 'COUNT', sortable: true, thStyle: 'width: 30%;', thClass: 'text-right', tdClass: 'text-right' },
          ],
          categoryFilter: {},
          fields: [
            { key: 'image', label: 'BASTARD', thStyle: 'width: 25%;' },
            { key: 'tokenId', label: 'INFO', thStyle: 'width: 15%;' },
            { key: 'attributes', label: 'ATTRIBUTES', thStyle: 'width: 25%;' },
            { key: 'description', label: 'LYRICS', thStyle: 'width: 35%;' },
          ],
          ownersFields: [
            { key: 'index', label: '#' },
            { key: 'owner', label: 'OWNER' },
            { key: 'tokens', label: 'TOKENS' },
          ],
          bokkysBastards: [3053, 4689, 5846, 5982, 6403, 7222, 7333, 7567, 9738, 10375, 10456, 10564, 10729, 10731, 10734, 10735, 10738, 10739, 10834, 11106],
        },


        computed: {
          getTotalSupply() {
            return this.data.length;
          },
          pagedTokensResults() {
            return this.tokensSearchResults.slice((this.tokensCurrentPage - 1) * this.tokensPageSize, this.tokensCurrentPage * this.tokensPageSize);
          },
          pagedCollatedOwnersResults() {
            return this.collatedOwners.slice((this.ownersCurrentPage - 1) * this.ownersPageSize, this.ownersCurrentPage * this.ownersPageSize);
          },
          getSelectedShowcase() {
            const MAXBASTARDSTODISPLAY = 14;
            function shuffleArray(array) {
              for (var i = array.length - 1; i > 0; i--) {
                var j = Math.floor(Math.random() * (i + 1));
                var temp = array[i];
                array[i] = array[j];
                array[j] = temp;
              }
            }
            let tokenIdsOwned = this.tokensOwned.slice(0);
            if (tokenIdsOwned.length == 0) {
              tokenIdsOwned = this.bokkysBastards.slice(0);
            }
            shuffleArray(tokenIdsOwned);
            return tokenIdsOwned.slice(0, MAXBASTARDSTODISPLAY);
          },
          getTags() {
            const collator = {};
            for (const [key, value] of Object.entries(this.tags)) {
              for (let i = 0; i < value.length; i++) {
                const tag = value[i];
                if (!collator[tag]) {
                  collator[tag] = 1;
                } else {
                  collator[tag] = parseInt(collator[tag]) + 1;
                }
              }
            }
            let results = [];
            results.push( { value: null, text: '(All)' });
            for (const [key, value] of Object.entries(collator)) {
              results.push( { value: key, text: key + ' (' + value + ')' });
            }
            results.sort(function(a, b) {
              return b.count - a.count;
            });
            return results;
          }
        },


        methods: {
          async loadOSData() {
            console.log("loadOSData: loadNFTs()" + BASTARDADDRESS);

            var db0 = new Dexie("BastardDB");
            db0.version(1).stores({
              apiData: '&tokenId,asset,timestamp'
            });

            const timestamp = parseInt(new Date() / 1000);
            const BATCHSIZE = 50; // Default 20, max 50
            const DELAY = 1000; // Millis
            let page = 0;
            const records = [];
            const delay = ms => new Promise(res => setTimeout(res, ms));
            await delay(DELAY);
            console.log("loadOSData: loadNFTs() 1 - this.getTotalSupply: " + this.getTotalSupply);
            const to = this.getTotalSupply;
            for (let i = 0; i < to; i += BATCHSIZE) {
              let url = "https://api.opensea.io/api/v1/assets?asset_contract_address=" + BASTARDADDRESS + "\&order_direction=desc\&limit=50\&offset=0";
              for (let j = i; j < i + BATCHSIZE && j < to; j++) {
                url = url + "&token_ids=" + j;
              }
              const elapsed = parseInt(new Date() / 1000) - timestamp;
              this.processing = "DOWNLOADING LIVE DATA FROM OPENSEA: " + i + " WITH BATCH SIZE " + BATCHSIZE + " OF " + this.getTotalSupply + ". ELAPSED " + elapsed + " SECONDS";
              const data = await fetch(url).then(response => response.json());
              if (data.assets && data.assets.length > 0) {
                for (let assetIndex = 0; assetIndex < data.assets.length; assetIndex++) {
                  const asset = data.assets[assetIndex];
                  records.push({ tokenId: asset.token_id, asset: asset, timestamp: timestamp });
                }
              }
              await delay(DELAY);

              console.log(JSON.stringify(records));
              await db0.apiData.bulkPut(records).then (function(){
                return db0.apiData.get(3);
              }).then(function (item) {
                // console.log("timestamp: " + item);
              }).catch(function(error) {
                console.log("error: " + error);
              });

              // data.forEach((datum) => {
              //   records.push({ rescueIndex: datum.details.rescueIndex, catId: datum.details.catId, data: datum, timestamp: timestamp });
              //   // console.log(JSON.stringify(records[records.length - 1], null, 2));
              //   // Vue.set(t.traitData, datum.details.catId, datum);
              //   // logDebug("NFTPostcard", "loadCatData() rescueIndex: " + datum.details.rescueIndex);
              //   // logDebug("NFTPostcard", "loadCatData() datum: " + JSON.stringify(datum, null, 2));
              //   // logDebug("NFTPostcard", "loadCatData() datum: " + JSON.stringify(t.traitData[datum.details.rescueIndex], null, 2));
              // });
              // await db0.apiData.bulkPut(records).then (function(){
              //   return db0.apiData.get(3);
              // }).then(function (item) {
              //   logDebug("moonCatDataModule", "loadMoonCatData() - timestamp: " + item.timestamp);
              // }).catch(function(error) {
              //    logError("moonCatDataModule", "loadMoonCatData() - error: " + error);
              // });
              //
              // const data1 = await db0.apiData.toArray();
              // logDebug("moonCatDataModule", "loadMoonCatData() Dexie - data1: " + JSON.stringify(data1));


            }
            this.processing = null;
            this.osAssets = osAssets;
            // localStorage.setItem('bastardsOSAssets', JSON.stringify(osAssets));
          },

          saveTags() {
            for (const [key, value] of Object.entries(this.tags)) {
              if (value.length == 0) {
                Vue.delete(this.tags, key);
              }
            }
            localStorage.setItem('bastardsTags', JSON.stringify(this.tags));
          },
          ensOrShortName(address) {
            let name = this.ensMap[address.toLowerCase()];
            if (name != null) {
              name = name.substring(0, 16);
            }
            return name;
          },
          calculateData() {
            const results = [];
            for (let i in BASTARDDATA) {
              const item = BASTARDDATA[i];
              item.mosaicurl = null;
              for (let k in item.attributes) {
                const attribute = item.attributes[k];
                if (attribute.trait_type == 'HYPE TYPE') {
                  if (attribute.value == 'HYPED AF (ANIMATED)') {
                    if (item.tokenId < 9000) {
                      item.mosaicurl = "hypedafmosaic/" + item.tokenId + ".png";
                    }
                  }
                }
              }
              results.push(item);
            }
            console.log(new Date().toUTCString() + " - calculateData() completed");
            return results;
          },
          calculateTokensOwned() {
            const results = [];
            if (this.owners.length > 0 && this.account) {
              const account = this.account.toLowerCase();
              for (let i in this.data) {
                const item = this.data[i];
                const owner = this.owners[i];
                if (owner && owner.toLowerCase() == account) {
                  results.push(item.tokenId);
                }
              }
            }
            console.log(new Date().toUTCString() + " - calculateTokensOwned() completed: " + JSON.stringify(results));
            return results;
          },
          calculateCategories() {
            const collator = {};
            for (let i in this.data) {
              const item = this.data[i];
              for (let k in item.attributes) {
                const attribute = item.attributes[k];
                const traitType = attribute.trait_type;
                const value = attribute.value;
                if (!collator[traitType]) {
                  collator[traitType] = {};
                }
                if (!collator[traitType][value]) {
                  collator[traitType][value] = 1;
                } else {
                  collator[traitType][value] = collator[traitType][value] + 1;
                }
              }
            }
            console.log(new Date().toUTCString() + " - calculateCategories() completed");
            return collator;
          },
          calculateSearchResults() {
            let results = [];
            let data = this.data.slice(0);
            const accountLowerCase = this.account == null ? null : this.account.toLowerCase();
            const selectedTags = this.selectedTags == null || (this.selectedTags.length == 1 && this.selectedTags[0] == null) ? null : this.selectedTags;
            for (let i in data) {
              const d = data[i];
              let include = true;
              function getAttribute(data1, category) {
                for (let attributeIndex in data1.attributes) {
                  const attribute = data1.attributes[attributeIndex];
                  if (attribute.trait_type == category) {
                    return attribute.value;
                  }
                }
                return null;
              }
              for (const [key, value] of Object.entries(this.categoryFilter)) {
                const attributeValue = getAttribute(d, key);
                if (!value[attributeValue]) {
                  include = false;
                  break;
                }
              }
              if (include && this.searchString != null && this.searchString.length > 0) {
                const s = this.searchString.toLowerCase();
                if (d.tokenId != this.searchString && (!d.description || !d.description.toLowerCase().includes(s))) {
                  include = false;
                }
              }
              if (include && this.searchAccount != null && this.searchAccount.length > 0) {
                const s = this.searchAccount.toLowerCase();
                const owner = this.owners[d.tokenId] ? this.owners[d.tokenId].toLowerCase() : null;
                const ensName = owner == null ? null : this.ensMap[owner];
                if (owner != null && owner.includes(s)) {
                } else if (ensName != null && ensName.includes(s)) {
                } else {
                  include = false;
                }
              }
              if (include) {
                if (selectedTags && selectedTags.length > 0) {
                  const tags = this.tags[d.tokenId];
                  let found = false;
                  if (tags) {
                    for (const selectedTag of selectedTags) {
                      for (const tag of tags) {
                        if (selectedTag == tag) {
                          found = true;
                          break;
                        }
                      }
                    }
                  }
                  if (!found) {
                    include = false;
                  }
                }
              }
              if (include) {
                results.push(d);
              }
            }
            console.log(new Date().toUTCString() + " - calculateSearchResults() completed");
            return results;
          },
          calculateCollatedOwners() {
            let results = [];
            if (this.owners.length > 0) {
              const collator = {};
              for (let i in this.data) {
                const item = this.data[i];
                const owner = this.owners[i];
                if (!collator[owner]) {
                  collator[owner] = [];
                }
                collator[owner].push(item.tokenId);
              }
              for (const [key, value] of Object.entries(collator)) {
                results.push({ owner: key, tokens: value, count: value.length });
              }
              results.sort(function(a, b) {
                return b.count - a.count;
              });
              for (let i in results) {
                results[i].index = i;
              }
            }
            console.log(new Date().toUTCString() + " - calculateCollatedOwners() completed");
            return results;
          },
          async recalculate(from) {
            console.log(new Date().toUTCString() + " recalculate(from: " + from + ") start");
            if (from != 'selectedTags') {
              this.data = this.calculateData();
              this.tokensOwned = this.calculateTokensOwned();
              this.categories = this.calculateCategories();
            }
            this.tokensSearchResults = this.calculateSearchResults();
            this.collatedOwners = this.calculateCollatedOwners();
            console.log(new Date().toUTCString() + " recalculate(from: " + from + ") completed");
          },
          filterChange(category, option) {
            if (!this.categoryFilter[category]) {
              Vue.set(this.categoryFilter, category, {});
            }
            if (this.categoryFilter[category][option]) {
              Vue.delete(this.categoryFilter[category], option);
              if (Object.keys(this.categoryFilter[category]) == 0) {
                Vue.delete(this.categoryFilter, category);
              }
            } else {
              Vue.set(this.categoryFilter[category], option, true);
            }
            this.recalculate('filterChange');
          },
          getSortedValuesForCategory(category) {
            const results = [];
            for (let categoryKey in this.categories[category]) {
              const c = this.categories[category][categoryKey];
              results.push({ categoryOption: categoryKey, categoryTotal: c })
            }
            results.sort(function(a, b) {
              return b.categoryTotal - a.categoryTotal;
            });
            return results;
          },
          async connect() {
            if (!window.ethereum) {
              alert("Please use the https://metamask.io addon with Firefox, Chromium, Opera or Chrome, or any other other web3 browser, if you would like to view your Ethereum wallet's BGANPUNKSV2.");
              this.connected = false;
              this.account = null;
            } else {
              if (!window.ethereum.isConnected() || !window.ethereum['isUnlocked']) {
                try {
                  const t = this;
                  function handleAccountsChanged(accounts) {
                    console.log("handleAccountsChanged: " + JSON.stringify(accounts));
                    t.account = accounts[0];
                    localStorage.setItem('bastardMyAccount', JSON.stringify(t.account));
                    t.recalculate('web3 account update');
                  }
                  if (!this.connected) {
                    window.ethereum.on('accountsChanged', handleAccountsChanged);
                  }

                  const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                  this.account = accounts[0];
                  localStorage.setItem('bastardMyAccount', JSON.stringify(this.account));
                } catch (e) {
                  console.log("connect(): Error connecting");
                }
              }
              const provider = new ethers.providers.Web3Provider(window.ethereum);
              const network = await provider.getNetwork();
              if (network.chainId == 1) {
                this.connected = true;
                const erc721Helper = new ethers.Contract(ERC721HELPERADDRESS, ERC721HELPERABI, provider);
                const info = await erc721Helper.tokenInfo(BASTARDADDRESS);
                const totalSupply = parseInt(info[2].toString());
                console.log(new Date().toUTCString() + " info:" + JSON.stringify(info));
                const owners = [];
                const NFTOWNERBATCHSIZE = 500;
                for (let i = 0; i < totalSupply; i += NFTOWNERBATCHSIZE) {
                  const to = (i + NFTOWNERBATCHSIZE > totalSupply) ? totalSupply : i + NFTOWNERBATCHSIZE;
                  this.processing = "RETRIEVING LIVE BGANPUNKSV2 ONWERSHIP RECORDS FROM THE ETHEREUM MAINNET: " + i + " - " + (parseInt(to) - 1) + " OF " + totalSupply;
                  const ownersResult = await erc721Helper.owners(BASTARDADDRESS, i, to);
                  console.log(new Date().toUTCString() + " from: " + i + ", to: " + to + ", size: " + ownersResult[0].length);
                  for (let j = 0; j < ownersResult[0].length; j++) {
                    owners.push(ownersResult[1][j]);
                  }
                }
                this.owners = owners;
                localStorage.setItem('bastardsOwners', JSON.stringify(owners));
                const ensMap = {};
                for (let i in owners) {
                  const owner = owners[i].toLowerCase();
                  if (!ensMap[owner]) {
                    ensMap[owner] = owners[i];
                  }
                }
                ensMap[this.account.toLowerCase()] = this.account;
                let addresses = Object.keys(ensMap);
                const ensReverseRecordsContract = new ethers.Contract(ENSREVERSERECORDSADDRESS, ENSREVERSERECORDSABI, provider);
                const ENSOWNERBATCHSIZE = 500;
                for (let i = 0; i < addresses.length; i += ENSOWNERBATCHSIZE) {
                  this.processing = "RETRIEVING LIVE ENS REVERSE RECORDS FROM THE ETHEREUM MAINNET: " + i + " OF " + addresses.length;
                  const batch = addresses.slice(i, parseInt(i) + ENSOWNERBATCHSIZE);
                  const allnames = await ensReverseRecordsContract.getNames(batch);
                  // NOT CHECKING ADDRESSES AS THE ADDRESSES CAME FROM A CONTRACT. AND account. const validNames = allnames.filter((n) => normalize(n) === n );
                  for (let j = 0; j < batch.length; j++) {
                    const address = batch[j];
                    const name = allnames[j];
                    ensMap[address] = name != null && name.length > 0 ? name : address;
                    // const normalized = normalize(address);
                  }
                }
                ensMap["0x000000000000000000000000000000000000dEaD".toLowerCase()] = "BurnAddress_";
                ensMap["0xcCcBF11AC3030ee8CD7a04CFE15a3718df6dD030".toLowerCase()] = "NFT20_";
                this.ensMap = ensMap;
                localStorage.setItem('bastardsENSMap', JSON.stringify(ensMap));
                this.processing = "RECALCULATING DATA";
                this.recalculate('web3 data retrieval');
                this.processing = null;
              } else {
                alert("Please switch to the Ethereum mainnet and refresh");
              }
            }
          },
          disconnect() {
            this.connected = false;
          },
          async displayToken(tokenId) {
            const xhr = new XMLHttpRequest();
            xhr.open('GET', this.data[tokenId].osimage);
            const t = this;
            xhr.onload = function() {
              if (xhr.response.substring(0, 3) == "GIF") {
                t.selectedItemIsGIF = true;
              } else {
                t.selectedItemIsGIF = false;
              }
              t.selectedTokenId = tokenId;
              t.$refs['my-modal'].show();
            }
            xhr.onerror = function() {
              alert('A network error occurred!');
            };
            xhr.send();
          },
          async onGIFFrameSelectionModalOpened() {
            const t = this;
            var element = document.getElementById("thegif1")
            if (t.selectedItemIsGIF) {
              this.selectedItemGIF = new SuperGif({ gif: element, loop_delay: 2000, max_width: 400, rubbable: true } );
              this.selectedItemGIF.load(function(){
                t.selectedItemFrames = t.selectedItemGIF.get_length();
                if (t.selectedItemFrame < 0 || t.selectedItemFrame >= t.selectedItemFrames) {
                  t.selectedItemFrame = 0;
                }
                t.selectedItemGIF.move_to(t.selectedItemFrame);
              });
            }
          },
          setFrame() {
            if (this.selectedItemGIF) {
              this.selectedItemGIF.move_to(this.selectedItemFrame);
            }
          },
        },


        created() {
          const separator = window.location.href.indexOf("/#/");
          if (separator > 0) {
            const parameter = window.location.href.substring(separator + 3);
            var reg = new RegExp('^[0-9]$');
            if (new RegExp('^[0-9]+$').test(parameter)) {
              this.searchString = parameter;
            } else {
              this.searchAccount = parameter;
            }
          }
        },


        mounted() {
          if (localStorage.getItem('bastardsOwners')) {
            this.owners = JSON.parse(localStorage.getItem('bastardsOwners'));
          }
          if (localStorage.getItem('bastardMyAccount')) {
            this.account = JSON.parse(localStorage.getItem('bastardMyAccount'));
          }
          if (localStorage.getItem('bastardsENSMap')) {
            this.ensMap = JSON.parse(localStorage.getItem('bastardsENSMap'));
          }
          if (localStorage.getItem('bastardsTags')) {
            this.tags = JSON.parse(localStorage.getItem('bastardsTags'));
          }
          if (localStorage.getItem('bastardsOSAssets')) {
            this.osAssets = JSON.parse(localStorage.getItem('bastardsOSAssets'));
            console.log(JSON.stringify(this.osAssets[0], null, 2));
          }
          this.recalculate("mounted");
        }
      })
    </script>
  </body>
</html>
